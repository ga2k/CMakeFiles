include_guard(GLOBAL)

# --------------------------------------------------------------------------------------------------
# Data Hygiene & Encoding Logic
# --------------------------------------------------------------------------------------------------

# Encodes a string field: replaces empty strings with a sentinel to avoid property deletion.
function(_hs_sql_field_to_storage inVal outVar)
    if ("${inVal}" STREQUAL "")
        set(${outVar} "[[EMPTY_SENTINEL]]" PARENT_SCOPE)
    else ()
        set(${outVar} "${inVal}" PARENT_SCOPE)
    endif ()
endfunction()

# Decodes a string field: replaces the sentinel back with an actual empty string.
function(_hs_sql_field_to_user inVal outVar)
    if ("${inVal}" STREQUAL "[[EMPTY_SENTINEL]]" OR NOT DEFINED inVal)
        set(${outVar} "" PARENT_SCOPE)
    else ()
        set(${outVar} "${inVal}" PARENT_SCOPE)
    endif ()
endfunction()

# Decodes a string field: replaces the sentinel back with an actual empty string.
function(_hs_sql_fields_to_user inVal outVar)
    string(REPLACE "[[EMPTY_SENTINEL]]" "" _done "${inVal}")
    set("${outVar}" "${_done}" PARENT_SCOPE)
endfunction()

# Encodes a CMake list for storage: replaces list separators (;) with a safe alternative.
function(_hs_sql_list_to_record inList outVar)
    string(REPLACE ";" "[[LIST_SEP]]" _encoded "${inList}")
    _hs_sql_field_to_storage("${_encoded}" _final)
    set(${outVar} "${_final}" PARENT_SCOPE)
endfunction()

# Decodes a record from storage back into a CMake list.
function(_hs_sql_record_to_list inRec outVar)
    _hs_sql_field_to_user("${inRec}" _decoded)
    string(REPLACE "[[LIST_SEP]]" ";" _final "${_decoded}")
    set(${outVar} "${_final}" PARENT_SCOPE)
endfunction()

# Internal Helper: Right-padded string
function(_hs_pad_string text width outVar)
    string(LENGTH "${text}" _len)
    set(_res "${text}")
    if (_len LESS width)
        math(EXPR _diff "${width} - ${_len}")
        foreach (_i RANGE 1 ${_diff})
            string(APPEND _res " ")
        endforeach ()
    elseif (_len GREATER width)
        # Truncation logic
        math(EXPR _cut "${width} - 3")
        if (_cut GREATER 0)
            string(SUBSTRING "${text}" 0 ${_cut} _sub)
            set(_res "${_sub}...")
        endif ()
    endif ()
    set(${outVar} "${_res}" PARENT_SCOPE)
endfunction()

# --------------------------------------------------------------------------------------------------
# Internal Infrastructure
# --------------------------------------------------------------------------------------------------
set_property(GLOBAL PROPERTY HS_NEXT_HNDL 1000)

macro(_hs_sql_generate_handle outVarName)
    get_property(_next GLOBAL PROPERTY HS_NEXT_HNDL)
    set(_newHndl "HS_HNDL_${_next}")
    math(EXPR _next "${_next} + 1")
    set_property(GLOBAL PROPERTY HS_NEXT_HNDL ${_next})
    set(${outVarName} "${_newHndl}" PARENT_SCOPE)
    set(_resolvedHndl "${_newHndl}")
endmacro()

macro(_hs_sql_resolve_handle varName outHndl)
    if (NOT DEFINED ${varName})
        message(FATAL_ERROR "SQL Error: Variable '${varName}' is not defined.")
    endif ()
    set(${outHndl} "${${varName}}")
    get_property(_exists GLOBAL PROPERTY "${${outHndl}}_TYPE" SET)
    if (NOT _exists)
        message(FATAL_ERROR "SQL Error: Variable '${varName}' contains '${${outHndl}}', not a valid SQL object.")
    endif ()
endmacro()

macro(_hs_sql_check_readonly hndl)
    get_property(_t GLOBAL PROPERTY "${hndl}_TYPE")
    if (_t MATCHES "VIEW$")
        message(FATAL_ERROR "SQL Error: Cannot mutate VIEW '${hndl}'. Views are read-only.")
    endif ()
endmacro()

# --------------------------------------------------------------------------------------------------
# DDL: CREATE
# --------------------------------------------------------------------------------------------------
function(CREATE type outHandleVarName)
    _hs_sql_generate_handle(${outHandleVarName})

    set(_label "<unnamed>")
    set(_cols "")
    set(_members "")
    set(_i 2)
    while (_i LESS ARGC)
        if ("${ARGV${_i}}" MATCHES "^(LABEL|AS)$")
            math(EXPR _i "${_i} + 1")
            set(_label "${ARGV${_i}}")
        elseif ("${ARGV${_i}}" STREQUAL "COLUMNS")
            math(EXPR _i "${_i} + 1")
            set(_cols "${ARGV${_i}}")
        elseif ("${ARGV${_i}}" STREQUAL "FROM")
            math(EXPR _i "${_i} + 1")
            while (_i LESS ARGC AND NOT "${ARGV${_i}}" MATCHES "^(LABEL|COLUMNS)$")
                _hs_sql_resolve_handle("${ARGV${_i}}" _mHndl)
                list(APPEND _members "${_mHndl}")
                math(EXPR _i "${_i} + 1")
            endwhile ()
            math(EXPR _i "${_i} - 1")
        endif ()
        math(EXPR _i "${_i} + 1")
    endwhile ()

    set_property(GLOBAL PROPERTY "${_resolvedHndl}_TYPE" "${type}")
    _hs_sql_field_to_storage("${_label}" _encLabel)
    set_property(GLOBAL PROPERTY "${_resolvedHndl}_LABEL" "${_encLabel}")

    if (type STREQUAL "TABLE")
        _hs_sql_list_to_record("${_cols}" _encCols)
        set_property(GLOBAL PROPERTY "${_resolvedHndl}_COLUMNS" "${_encCols}")
        set_property(GLOBAL PROPERTY "${_resolvedHndl}_ROW_COUNT" 0)
        set_property(GLOBAL PROPERTY "${_resolvedHndl}_NEXT_ROWID" 1)
        set_property(GLOBAL PROPERTY "${_resolvedHndl}_ROWIDS" "")

    elseif (type STREQUAL "VIEW")
        _hs_sql_list_to_record("${_members}" _encMems)
        set_property(GLOBAL PROPERTY "${_resolvedHndl}_MEMBERS" "${_encMems}")

    elseif (type STREQUAL "MATERIALIZED_VIEW")
        set_property(GLOBAL PROPERTY "${_resolvedHndl}_TYPE" "MATERIALIZED_VIEW")

        # 1. Schema Merging: Combine columns from all sources
        set(_allCols "")
        foreach (_m IN LISTS _members)
            get_property(_mc GLOBAL PROPERTY "${_m}_COLUMNS")
            list(APPEND _allCols ${_mc})
        endforeach ()
        list(REMOVE_DUPLICATES _allCols)
        _hs_sql_list_to_record("${_allCols}" _encCols)
        set_property(GLOBAL PROPERTY "${_resolvedHndl}_COLUMNS" "${_encCols}")
        set_property(GLOBAL PROPERTY "${_resolvedHndl}_ROWIDS" "")
        set_property(GLOBAL PROPERTY "${_resolvedHndl}_ROW_COUNT" 0)
        set_property(GLOBAL PROPERTY "${_resolvedHndl}_NEXT_ROWID" 1)

        # 2. Snapshot: Physically copy data
        foreach (_m IN LISTS _members)
            get_property(_mEncIDs GLOBAL PROPERTY "${_m}_ROWIDS")
            _hs_sql_record_to_list("${_mEncIDs}" _mIDs)
            get_property(_mEncCols GLOBAL PROPERTY "${_m}_COLUMNS")
            _hs_sql_record_to_list("${_mEncCols}" _mCols)

            foreach (_rid IN LISTS _mIDs)
                set(_rowVals "")
                foreach (_c IN LISTS _allCols)
                    if (_c IN_LIST _mCols)
                        get_property(_vEnc GLOBAL PROPERTY "${_m}_R${_rid}_${_c}")
                        _hs_sql_field_to_user("${vEnc}" _v)
                        list(APPEND _rowVals "${_v}")
                    else ()
                        _hs_sql_field_to_user("" _v)
                        list(APPEND _rowVals "${_v}")
                    endif ()
                endforeach ()
                # Use internal insert to bypass read-only check
                _hs_sql_internal_insert("${_resolvedHndl}" "${_rowVals}")
            endforeach ()
        endforeach ()

    elseif (type STREQUAL "DICTIONARY")
        set_property(GLOBAL PROPERTY "${_resolvedHndl}_TYPE" "DICTIONARY")
        set_property(GLOBAL PROPERTY "${_resolvedHndl}_KEYS" "")
    else ()
        msg(ALWAYS FATAL_ERROR "CREATE(${type}) :- Don't know how to create a ${type}, only
        TABLE
        VIEW
        MATERIALIZED_VIEW
        DICTIONARY
")
    endif ()
endfunction()

# --------------------------------------------------------------------------------------------------
# DML: INSERT & UPDATE
# --------------------------------------------------------------------------------------------------
function(INSERT kw tableVarName)
    _hs_sql_resolve_handle(${tableVarName} _h)
    _hs_sql_check_readonly(${_h})
    get_property(_type GLOBAL PROPERTY "${_h}_TYPE")

    if (_type STREQUAL "DICTIONARY")
        set(_key "")
        set(_val "")
        set(_isH FALSE)
        set(_i 2)
        while (_i LESS ARGC)
            if ("${ARGV${_i}}" STREQUAL "KEY")
                math(EXPR _i "${_i} + 1")
                set(_key "${ARGV${_i}}")
            elseif ("${ARGV${_i}}" STREQUAL "VALUE")
                math(EXPR _i "${_i} + 1")
                set(_val "${ARGV${_i}}")
            elseif ("${ARGV${_i}}" STREQUAL "HANDLE")
                math(EXPR _i "${_i} + 1")
                _hs_sql_resolve_handle("${ARGV${_i}}" _val)
                set(_isH TRUE)
            endif ()
            math(EXPR _i "${_i} + 1")
        endwhile ()

        get_property(_exists GLOBAL PROPERTY "${_h}_K_${_key}" SET)
        if (_exists)
            message(FATAL_ERROR "SQL Error: Key '${_key}' exists. Use UPDATE.")
        endif ()
        _hs_sql_field_to_storage("${_val}" _encVal)
        set_property(GLOBAL PROPERTY "${_h}_K_${_key}" "${_encVal}")
        set_property(GLOBAL PROPERTY "${_h}_K_${_key}_ISHANDLE" ${_isH})
        set_property(GLOBAL APPEND PROPERTY "${_h}_KEYS" "${_key}")

    else () # TABLE logic
        get_property(_encCols GLOBAL PROPERTY "${_h}_COLUMNS")
        _hs_sql_record_to_list("${_encCols}" _cols)
        get_property(_nextID GLOBAL PROPERTY "${_h}_NEXT_ROWID")
        set(_vIdx 2)
        if ("${ARGV${_vIdx}}" STREQUAL "VALUES")
            math(EXPR _vIdx "${_vIdx} + 1")
        endif ()
        foreach (_c IN LISTS _cols)
            _hs_sql_field_to_storage("${ARGV${_vIdx}}" _v)
            set_property(GLOBAL PROPERTY "${_h}_R${_nextID}_${_c}" "${_v}")
            math(EXPR _vIdx "${_vIdx} + 1")
        endforeach ()

        set_property(GLOBAL APPEND PROPERTY "${_h}_ROWIDS" "${_nextID}")
        get_property(_count GLOBAL PROPERTY "${_h}_ROW_COUNT")
        math(EXPR _newCount "${_count} + 1")
        set_property(GLOBAL PROPERTY "${_h}_ROW_COUNT" "${_newCount}")
        math(EXPR _newID "${_nextID} + 1")
        set_property(GLOBAL PROPERTY "${_h}_NEXT_ROWID" "${_newID}")
    endif ()
endfunction()

function(UPDATE tableVarName)
    _hs_sql_resolve_handle(${tableVarName} _h)
    _hs_sql_check_readonly(${_h})
    get_property(_type GLOBAL PROPERTY "${_h}_TYPE")

    if (_type STREQUAL "DICTIONARY")
        # Logic same as INSERT but without existence check
        set(_i 1)
        while (_i LESS ARGC)
            if ("${ARGV${_i}}" STREQUAL "KEY")
                math(EXPR _i "${_i} + 1")
                set(_key "${ARGV${_i}}")
            elseif ("${ARGV${_i}}" STREQUAL "VALUE")
                math(EXPR _i "${_i} + 1")
                _hs_sql_field_to_storage("${ARGV${_i}}" _encVal)
                set_property(GLOBAL PROPERTY "${_h}_K_${_key}" "${_encVal}")
                set_property(GLOBAL PROPERTY "${_h}_K_${_key}_ISHANDLE" FALSE)
            elseif ("${ARGV${_i}}" STREQUAL "HANDLE")
                math(EXPR _i "${_i} + 1")
                _hs_sql_resolve_handle("${ARGV${_i}}" _hndl)
                set_property(GLOBAL PROPERTY "${_h}_K_${_key}" "${_hndl}")
                set_property(GLOBAL PROPERTY "${_h}_K_${_key}_ISHANDLE" TRUE)
            endif ()
            math(EXPR _i "${_i} + 1")
        endwhile ()
    else () # TABLE logic
        set(_col "")
        set(_val "")
        set(_rid "")
        set(_i 1)
        while (_i LESS ARGC)
            if ("${ARGV${_i}}" STREQUAL "COLUMN")
                math(EXPR _i "${_i} + 1")
                set(_col "${ARGV${_i}}")
            elseif ("${ARGV${_i}}" STREQUAL "SET")
                math(EXPR _i "${_i} + 1")
                set(_val "${ARGV${_i}}")
            elseif ("${ARGV${_i}}" STREQUAL "ROWID")
                math(EXPR _i "${_i} + 1")
                if ("${ARGV${_i}}" STREQUAL "=")
                    math(EXPR _i "${_i} + 1")
                endif ()
                set(_rid "${ARGV${_i}}")
            endif ()
            math(EXPR _i "${_i} + 1")
        endwhile ()
        if (_h AND _rid AND _col)
            _hs_sql_field_to_storage("${_val}" _enc)
            set_property(GLOBAL PROPERTY "${_h}_R${_rid}_${_col}" "${_enc}")
        else ()
            message(FATAL_ERROR "SQL UPDATE: Missing required parameters (Target: ${_h}, Row: ${_rid}, Col: ${_col})")
        endif ()

    endif ()
endfunction()

# --------------------------------------------------------------------------------------------------
# DQL: SELECT
# --------------------------------------------------------------------------------------------------
function(SELECT mode)
    math(EXPR _lastIdx "${ARGC} - 1")
    set(_intoVar "${ARGV${_lastIdx}}")
    _hs_sql_resolve_handle("${ARGV2}" _h)
    get_property(_type GLOBAL PROPERTY "${_h}_TYPE")

    if (_type STREQUAL "DICTIONARY")
        set(_targetKey "")
        set(_i 3)
        while (_i LESS ARGC)
            if ("${ARGV${_i}}" MATCHES "^(NAME|KEY)$")
                math(EXPR _i "${_i} + 1")
                if("${ARGV${_i}}" STREQUAL "=")
                    math(EXPR _i "${_i} + 1")
                endif ()
                set(_targetKey "${ARGV${_i}}")
            endif ()
            math(EXPR _i "${_i} + 1")
        endwhile ()
        get_property(_raw GLOBAL PROPERTY "${_h}_K_${_targetKey}")
        _hs_sql_field_to_user("${_raw}" _final)
        set(${_intoVar} "${_final}" PARENT_SCOPE)
        return()
    endif ()

    if (_type STREQUAL "VIEW")
        get_property(_encMems GLOBAL PROPERTY "${_h}_MEMBERS")
        _hs_sql_record_to_list("${_encMems}" _members)
        set(_res "")
        set(_last "")

        set(_args ${ARGV})
        list(REMOVE_AT _args 0 1 2)
        list(REMOVE_AT _args -1)
        list(REMOVE_AT _args -1)
        foreach (_m IN LISTS _members)
            set(_mVar "_v_${_m}")
            set(${_mVar} "${_m}")
            SELECT(${mode} FROM _m ${_args} INTO _sub)
            if (_sub)
                list(APPEND _res "${_sub}")
                set(_last "${_sub}")
            endif ()
        endforeach ()
        list(LENGTH _res _matches)
        if(_matches EQUAL 1)
            set(${_intoVar} "${_last}" PARENT_SCOPE)
        else ()
            set(${_intoVar} "${_res}" PARENT_SCOPE)
        endif ()
        return()
    endif ()

    # TABLE Logic
    set(_whereCols "")
    set(_whereOps "")
    set(_whereVals "")
    set(_tRow "")
    set(_tCol "")
    set(_i 3)
    while (_i LESS ARGC)
        if ("${ARGV${_i}}" MATCHES "^(ROWID|INDEX)$")
            math(EXPR _i "${_i} + 1")
            if ("${ARGV${_i}}" STREQUAL "=")
                math(EXPR _i "${_i} + 1")
            endif ()
            set(_tRow "${ARGV${_i}}")
        elseif ("${ARGV${_i}}" STREQUAL "COLUMN")
            math(EXPR _i "${_i} + 1")
            if ("${ARGV${_i}}" STREQUAL "=")
                math(EXPR _i "${_i} + 1")
                set(_tCol "${ARGV${_i}}")
            else ()
                set(_cName "${ARGV${_i}}")
                math(EXPR _i "${_i} + 1")
                if ("${ARGV${_i}}" MATCHES "^(=|LIKE)$")
                    list(APPEND _whereCols "${_cName}")
                    list(APPEND _whereOps "${ARGV${_i}}")
                    math(EXPR _i "${_i} + 1")
                    list(APPEND _whereVals "${ARGV${_i}}")
                else ()
                    set(_tCol "${_cName}")
                    math(EXPR _i "${_i} - 1")
                endif ()
            endif ()
        endif ()
        math(EXPR _i "${_i} + 1")
    endwhile ()

    if (mode MATCHES "^(VALUE|HANDLE)$" AND _tRow)
        if (NOT _tCol AND _tRow MATCHES "^[0-9]+$")
            get_property(_encCols GLOBAL PROPERTY "${_h}_COLUMNS")
            _hs_sql_record_to_list("${_encCols}" _allCols)
            math(EXPR _cIdx "${_tRow} - 1")
            list(GET _allCols ${_cIdx} _tCol)
        endif ()
        get_property(_raw GLOBAL PROPERTY "${_h}_R${_tRow}_${_tCol}")
        _hs_sql_field_to_user("${_raw}" _final)
        set(${_intoVar} "${_final}" PARENT_SCOPE)
        return()
    endif ()


    # B. Restored Multi-row Filtering Logic (SELECT * / SELECT COUNT)
    get_property(_encIDs GLOBAL PROPERTY "${_h}_ROWIDS")
    _hs_sql_record_to_list("${_encIDs}" _ids)
    get_property(_encCols GLOBAL PROPERTY "${_h}_COLUMNS")
    _hs_sql_record_to_list("${_encCols}" _allCols)

    set(_matches "")
    set(_matched_column_name "")

    foreach (_rid IN LISTS _ids)
        set(_rowPass TRUE)
        list(LENGTH _whereCols _filterCount)
        if (_filterCount GREATER 0)
            math(EXPR _maxF "${_filterCount} - 1")
            foreach (_fIdx RANGE ${_maxF})
                list(GET _whereCols ${_fIdx} _fCol)
                list(GET _whereOps ${_fIdx} _fOp)
                list(GET _whereVals ${_fIdx} _fVal)
                get_property(_val GLOBAL PROPERTY "${_h}_R${_rid}_${_fCol}")
                _hs_sql_field_to_user("${_val}" _actualVal)

                if (_fOp STREQUAL "=")
                    if (NOT "${_actualVal}" STREQUAL "${_fVal}")
                        set(_rowPass FALSE)
                        break()
                    endif ()
                elseif (_fOp STREQUAL "LIKE")
                    string(REPLACE "*" ".*" _regex "${_fVal}")
                    if (NOT "${_actualVal}" MATCHES "^${_regex}$")
                        set(_rowPass FALSE)
                        break()
                    endif ()
                endif ()
            endforeach ()
        endif ()

        if (_rowPass)
            list(APPEND _matches "${_rid}")
            if(_fCol)
                list(APPEND _matched_column_name "${_fCol}")
            elseif(_tCol)
                list(APPEND _matched_column_name "${_tCol}")
            endif ()
        endif ()
    endforeach ()
    # --- C. Shape the Output ---
    if (mode STREQUAL "COUNT")
        list(LENGTH _matches _count)
        set(${_intoVar} "${_count}" PARENT_SCOPE)
        return()
    endif ()

    # If the user specifically asked for a VALUE (scalar string)
    if (mode STREQUAL "VALUE")
        list(LENGTH _matches _matchCount)
        if (_matchCount GREATER 0)
            # Return the value from the first matching row
            list(GET _matches 0 _firstID)
            if (_targetCol)
                set(_use_this_column_name "${_targetCol}")
            else ()
                list(GET _matched_column_name 0 _use_this_column_name)
            endif ()

            get_property(_val GLOBAL PROPERTY "${_h}_R${_firstID}_${_use_this_column_name}")
            _hs_sql_field_to_user("${_val}" _final_result)
            set(${_intoVar} "${_final_result}" PARENT_SCOPE)
        else ()
            # No rows matched: return empty string
            set(${_intoVar} "" PARENT_SCOPE)
        endif ()
        return()
    endif ()

    # --- Inside SELECT function ---
    if (mode STREQUAL "ROW")
        if (NOT _targetRow)
            # If no ROWID specified, default to the first match
            list(GET _matches 0 _targetRow)
        endif ()

        set(_rowList "")
        get_property(_encCols GLOBAL PROPERTY "${_h}_COLUMNS")
        _hs_sql_record_to_list("${_encCols}" _allCols)

        foreach (_col IN LISTS _allCols)
            get_property(_v GLOBAL PROPERTY "${_h}_R${_targetRow}_${_col}")
#            _hs_sql_field_to_user("${_v}" _v)
            list(APPEND _rowList "${_v}")
        endforeach ()

        set(${_intoVar} "${_rowList}" PARENT_SCOPE)
        return()
    endif ()

    # --- D. Default: Return a result set (New Table Handle) ---
    CREATE(TABLE _tmpRes LABEL "result_set" COLUMNS "${_allCols}")
    foreach (_mID IN LISTS _matches)
        set(_rowValues "")
        foreach (_col IN LISTS _allCols)
            get_property(_val GLOBAL PROPERTY "${_h}_R${_mID}_${_col}")
            list(APPEND _rowValues "${_val}")
        endforeach ()
        INSERT(INTO _tmpRes VALUES ${_rowValues})
    endforeach ()

    set(${_intoVar} "${_tmpRes}" PARENT_SCOPE)
endfunction()

# --------------------------------------------------------------------------------------------------
# DML: DELETE
# --------------------------------------------------------------------------------------------------
function(DELETE kwFrom tableVarName)
    _hs_sql_resolve_handle(${tableVarName} _h)
    _hs_sql_check_readonly(${_h})

    set(_rid "")
    set(_i 2)
    while(_i LESS ARGC)
        if("${ARGV${_i}}" STREQUAL "ROWID")
            math(EXPR _i "${_i} + 1")
            if("${ARGV${_i}}" STREQUAL "=")
                math(EXPR _i "${_i} + 1")
            endif()
            set(_rid "${ARGV${_i}}")
        endif()
        math(EXPR _i "${_i} + 1")
    endwhile()

    if(_rid)
        # Remove from the ROWIDS list
        get_property(_ids GLOBAL PROPERTY "${_h}_ROWIDS")
        list(REMOVE_ITEM _ids "${_rid}")
        set_property(GLOBAL PROPERTY "${_h}_ROWIDS" "${_ids}")

        # Update Count
        list(LENGTH _ids _newCount)
        set_property(GLOBAL PROPERTY "${_h}_ROW_COUNT" "${_newCount}")

        # Note: We leave the actual R${_rid}_COL properties in global memory
        # but they are now unreachable via standard SELECT/DUMP.
    endif()
endfunction()

# --------------------------------------------------------------------------------------------------
# Introspection & Utilities
# --------------------------------------------------------------------------------------------------

function(TYPEOF handleVarName outVar)
    _hs_sql_resolve_handle(${handleVarName} _h)
    get_property(_type GLOBAL PROPERTY "${_h}_TYPE")
    set(${outVar} "${_type}" PARENT_SCOPE)
endfunction()

function(LABEL kwOF handleVarName kwINTO outVar)
    _hs_sql_resolve_handle(${handleVarName} _h)
    get_property(_raw GLOBAL PROPERTY "${_h}_LABEL")
    _hs_sql_field_to_user("${_raw}" _final)
    set(${outVar} "${_final}" PARENT_SCOPE)
endfunction()

function(GET_COLUMNS handleVarName outVar)
    _hs_sql_resolve_handle(${handleVarName} _h)
    get_property(_raw GLOBAL PROPERTY "${_h}_COLUMNS")
    _hs_sql_record_to_list("${_raw}" _final)
    set(${outVar} "${_final}" PARENT_SCOPE)
endfunction()

function(GET_ROWIDS handleVarName outVar)
    _hs_sql_resolve_handle(${handleVarName} _h)
    get_property(_ids GLOBAL PROPERTY "${_h}_ROWIDS")
    set(${outVar} "${_ids}" PARENT_SCOPE)
endfunction()

function(DESCRIBE handleVarName)
    _hs_sql_resolve_handle(${handleVarName} _h)
    get_property(_type GLOBAL PROPERTY "${_h}_TYPE")
    get_property(_rawLabel GLOBAL PROPERTY "${_h}_LABEL")
    _hs_sql_field_to_user("${_rawLabel}" _label)

    message("Object: ${_label}")
    message("Type:   ${_type}")

    if(_type STREQUAL "TABLE" OR _type STREQUAL "MATERIALIZED_VIEW")
        get_property(_rawCols GLOBAL PROPERTY "${_h}_COLUMNS")
        _hs_sql_record_to_list("${_rawCols}" _cols)
        get_property(_count GLOBAL PROPERTY "${_h}_ROW_COUNT")
        message("Rows:   ${_count}")
        message("Cols:   ${_cols}")
    elseif(_type STREQUAL "VIEW")
        get_property(_rawMems GLOBAL PROPERTY "${_h}_MEMBERS")
        _hs_sql_record_to_list("${_rawMems}" _mems)
        message("Source Members: ${_mems}")
    endif()
endfunction()

# --------------------------------------------------------------------------------------------------
# Validation: ASSERT
# --------------------------------------------------------------------------------------------------
function(ASSERT handleVarName)
    _hs_sql_resolve_handle(${handleVarName} _h)
    set(_expectedType "")
    set(_expectedCount "")

    set(_i 1)
    while(_i LESS ARGC)
        if("${ARGV${_i}}" STREQUAL "TYPE")
            math(EXPR _i "${_i} + 1")
            set(_expectedType "${ARGV${_i}}")
        elseif("${ARGV${_i}}" STREQUAL "COUNT")
            math(EXPR _i "${_i} + 1")
            set(_expectedCount "${ARGV${_i}}")
        endif()
        math(EXPR _i "${_i} + 1")
    endwhile()

    if(_expectedType)
        get_property(_actualType GLOBAL PROPERTY "${_h}_TYPE")
        if(NOT "${_actualType}" STREQUAL "${_expectedType}")
            message(FATAL_ERROR "ASSERT FAILED: Type is '${_actualType}', expected '${_expectedType}'")
        endif()
    endif()

    if(NOT "${_expectedCount}" STREQUAL "")
        get_property(_actualCount GLOBAL PROPERTY "${_h}_ROW_COUNT")
        if(NOT "${_actualCount}" EQUAL "${_expectedCount}")
            message(FATAL_ERROR "ASSERT FAILED: Count is ${_actualCount}, expected ${_expectedCount}")
        endif()
    endif()
endfunction()

# --------------------------------------------------------------------------------------------------
# Introspection: DUMP
# --------------------------------------------------------------------------------------------------
function(DUMP kwFrom handleVarName)
    set(_verbose)
    set(_deep)
    set(_intoVar)
    set(_depth 1)
    set(_offset_padding)
    set(_depth_note)
    set(_padding_str "\t")
    set(_out)

    foreach (_arg IN LISTS ARGN)
        if (_arg STREQUAL "VERBOSE")
            set(_verbose "VERBOSE")
        elseif (_arg STREQUAL "DEEP")
            set(_deep "DEEP")
        elseif (_arg STREQUAL "INTO")
            set(_catchNext TRUE)
        elseif (_catchNext)
            set(_intoVar "${_arg}")
            set(_catchNext FALSE)
        elseif (_arg STREQUAL "DEPTH")
            set(_catchNextDepth TRUE)
        elseif (_catchNextDepth)
            set(_depth "${_arg}")
            set(_catchNext FALSE)
        endif ()
    endforeach ()

    _hs_sql_resolve_handle(${handleVarName} _h)

    string(REPEAT "${_padding_str}" ${_depth} _offset_padding)
    if(_depth GREATER 1)
        set(_depth_note "\n\n${_offset_padding}Depth: ${_depth} ")
    endif ()

    get_property(_type GLOBAL PROPERTY "${_h}_TYPE")
    get_property(_encLabel GLOBAL PROPERTY "${_h}_LABEL")
    _hs_sql_field_to_user("${_encLabel}" _label)

    string(APPEND _out "${_depth_note}--- SQL DUMP: ${_label} (${_type}) [HANDLE: ${_h}] ---\n")

    # --- VIEW Logic (Show member pointers) ---
    if (_type STREQUAL "VIEW")
        get_property(_encMembers GLOBAL PROPERTY "${_h}_MEMBERS")
        _hs_sql_record_to_list("${_encMembers}" _members)
        string(APPEND _out "${_offset_padding} MEMBERS: ${_members}\n")
        if (_deep)
            foreach (_m IN LISTS _members)
                set(_mVar "_v_${_m}")
                set(${_mVar} "${_m}")
                math(EXPR _level "${_depth} + 1")
                DUMP(FROM ${_mVar} ${_verbose} ${_deep} INTO _inner DEPTH ${_level})
                string(APPEND _out "${_offset_padding}  |--- MEMBER ${_m}: ${_inner}\n")
            endforeach ()
        endif ()

    elseif (_type STREQUAL "DICTIONARY")
        get_property(_keys GLOBAL PROPERTY "${_h}_KEYS")
        foreach(_pass RANGE 1 2)
            foreach (_k IN LISTS _keys)
                get_property(_raw GLOBAL PROPERTY "${_h}_K_${_k}")
                _hs_sql_field_to_user("${_raw}" _v)
                get_property(_isH GLOBAL PROPERTY "${_h}_K_${_k}_ISHANDLE")
                if(_pass EQUAL 1)
                    if (_isH)
                        string(APPEND _out "${_offset_padding} [KEY] ${_k} => [HANDLE] ${_v}\n")
                    else ()
                        string(APPEND _out "${_offset_padding} [KEY] ${_k} => [VALUE] \"${_v}\"\n")
                    endif ()
                else ()
                    if(_deep)
                        math(EXPR _level "${_depth} + 1")
                        DUMP(FROM _v ${_verbose} ${_deep} INTO _ours DEPTH ${_level})
                        set(_out "${_out}\n${_ours}")
                    endif ()
                endif ()
            endforeach ()
        endforeach ()
    elseif (_type MATCHES "TABLE|MATERIALIZED_VIEW")
        get_property(_encCols GLOBAL PROPERTY "${_h}_COLUMNS")
        _hs_sql_record_to_list("${_encCols}" _cols)
        get_property(_ids GLOBAL PROPERTY "${_h}_ROWIDS")

        if (NOT _verbose)
            string(APPEND _out "${_offset_padding}    COLS: ${_cols}\n")
        else ()
            # --- PASS 1: MEASURE ---
            # Initialize widths with header lengths

            foreach (_c IN LISTS _cols)
                string(LENGTH "${_c}" _len)
                set(_w_${_c} ${_len})
            endforeach ()
            set(_w_ROW 3) # Minimum width for "Row" header

            foreach (_rid IN LISTS _ids)
                foreach (_c IN LISTS _cols)
                    get_property(_encVal GLOBAL PROPERTY "${_h}_R${_rid}_${_c}")
                    _hs_sql_field_to_user("${_encVal}" _val)
                    _hs_sql_record_to_list("${_val}" _valList)

                    # Apply GitHub domain omission logic for measurement
                    if (_val MATCHES "^https://github.com/(.*)")
                        set(_val "${CMAKE_MATCH_1}")
                    endif ()

                    # Split by semicolon to find the longest individual line in a multi-value field
                    string(REPLACE ";" "\n" _lines "${_val}")
                    string(REPLACE "\n" ";" _lineList "${_lines}")
                    foreach (_line IN LISTS _lineList)
                        string(LENGTH "${_line}" _lLen)
                        if (_lLen GREATER _w_${_c})
                            set(_w_${_c} ${_lLen})
                        endif ()
                    endforeach ()
                endforeach ()
            endforeach ()

            # --- PASS 2: LAYOUT ---
            # Build Header Row
            set(_header "    | Row |")
            foreach (_c IN LISTS _cols)
                _hs_pad_string("${_c}" ${_w_${_c}} _padded)
                string(APPEND _header " ${_padded} |")
            endforeach ()
            string(APPEND _out "${_offset_padding}${_header}\n")

            # Build Rows
            foreach (_rid IN LISTS _ids)
                set(_rowLines 1)
                # Determine how many sub-lines this row needs
                foreach (_c IN LISTS _cols)
                    get_property(_encVal GLOBAL PROPERTY "${_h}_R${_rid}_${_c}")
                    _hs_sql_field_to_user("${_encVal}" _val)
                    _hs_sql_record_to_list("${_val}" _valList)
                    string(REPLACE "&" ";" _noAmp "${_val}")
                    string(REPLACE ";" "\n" _lines "${_noAmp}")
                    string(REPLACE "\n" ";" _lineList "${_lines}")
                    list(LENGTH _lineList _lCount)
                    if (_lCount GREATER _rowLines)
                        set(_rowLines ${_lCount})
                    endif ()
                endforeach ()

                # Print each sub-line for the current row
                math(EXPR _maxLineIdx "${_rowLines} - 1")
                foreach (_li RANGE ${_maxLineIdx})
                    if (_li EQUAL 0)
                        _hs_pad_string("${_rid}" 3 _pRid)
                        set(_lineStr "    | ${_pRid} |")
                    else ()
                        set(_lineStr "    |     |")
                    endif ()

                    foreach (_c IN LISTS _cols)
                        get_property(_encVal GLOBAL PROPERTY "${_h}_R${_rid}_${_c}")
                        _hs_sql_field_to_user("${_encVal}" _val)
                        _hs_sql_record_to_list("${_val}" _valList)

                        # Apply GitHub domain omission for display
                        if (_val MATCHES "^https://github.com/(.*)")
                            set(_val "${CMAKE_MATCH_1}")
                        endif ()
                        _hs_sql_field_to_user("${_val}" _maybe_blank)
                        string(REPLACE "&&" "&" _single_amp "${_maybe_blank}")
                        string(REPLACE "&" ";" _no_amp "${_single_amp}")
                        string(REPLACE ";" "\n" _lines "${_no_amp}")
                        string(REPLACE "\n" ";" _lineList "${_lines}")

                        list(LENGTH _lineList _currentMax)
                        if (_li LESS _currentMax)
                            list(GET _lineList ${_li} _cellText)
                        else ()
                            set(_cellText "")
                        endif ()

                        _hs_pad_string("${_cellText}" ${_w_${_c}} _paddedCell)
                        string(APPEND _lineStr " ${_paddedCell} |")
                    endforeach ()
                    string(APPEND _out "${_offset_padding}${_lineStr}\n")
                endforeach ()
            endforeach ()
        endif ()
    endif ()

    if (_intoVar)
        set(${_intoVar} "${_out}" PARENT_SCOPE)
    else ()
        message("${_out}")
    endif ()
endfunction()
